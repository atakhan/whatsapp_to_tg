# Текстовая расшифровка файла whatsapp_connect.py

## Общее описание

Файл `whatsapp_connect.py` содержит сервис для подключения к WhatsApp Web через Playwright (автоматизацию браузера). Это основной модуль, который управляет сессиями WhatsApp, подключениями, получением QR-кодов, парсингом чатов и сообщений.

**Размер файла:** ~2595 строк кода  
**Основной класс:** `WhatsAppConnectService`  
**Технология:** Playwright (автоматизация браузера Chromium в headless режиме)

---

## Импорты и зависимости

### Внешние библиотеки:
- `playwright.async_api` - для автоматизации браузера
- `asyncio` - для асинхронных операций
- `base64` - для кодирования QR-кодов
- `json` - для работы с JSON данными
- `time`, `datetime` - для работы со временем
- `pathlib.Path` - для работы с путями файловой системы
- `logging` - для логирования

### Внутренние модули:
- `app.core.config` - настройки приложения
- `app.core.logging_setup` - настройка логирования с trace_id и request_id

---

## Константы

- `QR_WAIT_TIMEOUT_MS = 30000` - таймаут ожидания QR-кода (30 секунд)

---

## Класс WhatsAppConnectService

### Назначение
Управляет всеми подключениями к WhatsApp Web, сессиями, браузерными контекстами, парсингом чатов и сообщений.

### Атрибуты класса (в `__init__`):
- `self.sessions: Dict[str, Dict]` - словарь активных сессий (session_id -> {browser, context, page, status})
- `self.playwright` - экземпляр Playwright
- `self.browser: Optional[Browser]` - браузер Chromium
- `self.sessions_dir: Path` - директория для хранения сессий (из настроек `WHATSAPP_SESSIONS_DIR`)

---

## Методы класса

### 1. `__init__(self)`
**Назначение:** Инициализация сервиса  
**Что делает:**
- Создает пустой словарь сессий
- Инициализирует переменные для Playwright и браузера
- Создает директорию для сессий, если её нет

---

### 2. `async def initialize(self)`
**Назначение:** Инициализация Playwright браузера  
**Что делает:**
- Запускает Playwright (если еще не запущен)
- Запускает браузер Chromium в headless режиме
- Настраивает аргументы браузера (`--no-sandbox`, `--disable-setuid-sandbox`)

**Когда вызывается:** При первом подключении или переиспользовании сессии

---

### 3. `async def shutdown(self)`
**Назначение:** Завершение работы и очистка ресурсов  
**Что делает:**
- Закрывает все активные сессии
- Закрывает браузер
- Останавливает Playwright

**Когда вызывается:** При завершении работы приложения

---

### 4. `def get_session_path(self, session_id: str) -> Path`
**Назначение:** Получить путь к директории сессии  
**Возвращает:** `Path` объект с путем к директории сессии

---

### 5. `def list_existing_sessions(self) -> List[str]`
**Назначение:** Получить список всех существующих сессий на диске  
**Возвращает:** Список ID сессий, у которых есть директория `browser_data`

**Логика:**
- Проверяет директорию сессий
- Ищет поддиректории с `browser_data`
- Возвращает список имен директорий (session_id)

---

### 6. `async def check_session_exists(self, session_id: str) -> bool`
**Назначение:** Проверить, существует ли сессия на диске  
**Возвращает:** `True` если директория сессии существует

---

### 7. `async def try_reuse_session(self, session_id: str) -> Dict`
**Назначение:** Попытка переиспользовать существующую сессию WhatsApp  
**Возвращает:** Словарь с информацией о результате:
- `{"reused": True, "status": "ready", "connected_at": "..."}` - если сессия успешно переиспользована
- `{"reused": False, "reason": "..."}` - если не удалось переиспользовать

**Логика работы:**
1. Проверяет, есть ли сессия уже в памяти и готова ли она
2. Проверяет существование директории сессии на диске
3. Проверяет наличие `browser_data` (данные браузера)
4. Создает persistent browser context с существующими данными
5. Переходит на `https://web.whatsapp.com`
6. Проверяет, подключен ли WhatsApp (ищет элементы чат-листа)
7. Если подключен - сохраняет сессию в памяти и возвращает успех

**Особенности:**
- Использует `launch_persistent_context` для сохранения cookies и состояния
- Переопределяет `navigator.webdriver` чтобы скрыть автоматизацию
- Использует реалистичный User-Agent
- Ждет 3 секунды после загрузки страницы

---

### 8. `async def start_connection(self, session_id: str) -> Dict`
**Назначение:** Начать процесс подключения к WhatsApp Web (новое подключение)  
**Возвращает:** Словарь с QR-кодом и статусом:
```python
{
    "session_id": str,
    "qr_code": str (base64 PNG),
    "status": "waiting_qr",
    "expires_at": str (ISO datetime)
}
```

**Логика работы:**
1. Инициализирует Playwright
2. Проверяет, не подключена ли уже сессия
3. Создает директорию для сессии
4. Создает persistent browser context с новой директорией
5. Переходит на `https://web.whatsapp.com`
6. Ждет появления QR-кода
7. Ищет QR-код по canvas элементам (размер 200-400px, квадратный)
8. Кодирует QR-код в base64 PNG
9. Запускает мониторинг подключения в фоне
10. Возвращает QR-код и статус

**Особенности:**
- Создает новую сессию (не переиспользует)
- Использует persistent context для сохранения состояния
- QR-код ищется по размеру canvas (228x228px обычно)
- Мониторинг подключения запускается асинхронно

---

### 9. `async def _monitor_connection(self, session_id: str)`
**Назначение:** Мониторинг процесса подключения (фоновый процесс)  
**Что делает:**
- Периодически проверяет, исчез ли QR-код
- Проверяет, появились ли элементы чат-листа (признак подключения)
- Обновляет статус сессии при успешном подключении
- Устанавливает таймаут (300 секунд по умолчанию)

**Логика:**
1. Ждет исчезновения QR-кода
2. Проверяет наличие элементов чат-листа через `get_status`
3. Если подключено - обновляет статус сессии на `'ready'`
4. Логирует время подключения

**Когда вызывается:** Автоматически из `start_connection` в фоновом режиме

---

### 10. `async def get_status(self, session_id: str) -> Dict`
**Назначение:** Получить текущий статус сессии  
**Возвращает:** Словарь со статусом:
```python
{
    "status": "disconnected" | "waiting_qr" | "ready" | "error",
    "connected_at": str (ISO datetime) | None,
    "session_id": str
}
```

**Логика:**
1. Проверяет, существует ли сессия в памяти
2. Если сессия есть - проверяет статус в памяти
3. Если статус `'ready'` - дополнительно проверяет наличие элементов чат-листа на странице
4. Возвращает актуальный статус

**Селекторы для проверки подключения:**
- `div[data-testid="chatlist"]`
- `div[role="listbox"]`
- `div[data-testid="chat"]`
- `div[aria-label*="Chat"]`

---

### 11. `async def cleanup_session(self, session_id: str) -> bool`
**Назначение:** Очистка и закрытие сессии  
**Возвращает:** `True` если сессия была закрыта, `False` если не найдена

**Что делает:**
1. Проверяет существование сессии
2. Закрывает browser context
3. Удаляет сессию из памяти
4. Логирует результат

---

### 12. `def is_connected(self, session_id: str) -> bool`
**Назначение:** Проверить, подключена ли сессия  
**Возвращает:** `True` если сессия существует и имеет статус `'ready'`

---

### 13. `async def get_chats_streaming(self, session_id: str) -> AsyncGenerator[List[Dict], None]`
**Назначение:** Получить список чатов с потоковой передачей (streaming)  
**Возвращает:** AsyncGenerator, который yield'ит батчи чатов

**Что делает:**
1. Проверяет, что сессия существует и готова
2. Ищет контейнер со списком чатов
3. Парсит чаты батчами (по 10 штук)
4. Yield'ит каждый батч как список словарей с данными чатов
5. В конце yield'ит финальный батч и завершает

**Формат данных чата:**
```python
{
    "id": str,  # например "chat_2__________"
    "name": str,  # имя чата
    "last_message": str | None,  # последнее сообщение
    "timestamp": str | None,  # время последнего сообщения
    "unread_count": int,  # количество непрочитанных
    "avatar": str | None  # base64 изображение аватара
}
```

**Селекторы для поиска чатов:**
- `div[role="row"]` - строки чатов
- `div[aria-label*="Chat"]` - контейнер чатов
- `div[data-testid="cell-frame-container"]` - контейнер ячейки чата

**Особенности:**
- Использует Server-Sent Events (SSE) подход через AsyncGenerator
- Парсит чаты постепенно, не блокируя выполнение
- Обрабатывает ошибки и логирует их

---

### 14. `async def _parse_chats_batch(self, page, start_index: int, batch_size: int) -> List[Dict]`
**Назначение:** Парсинг батча чатов (вспомогательный метод)  
**Параметры:**
- `page` - Playwright Page объект
- `start_index` - начальный индекс для парсинга
- `batch_size` - размер батча (обычно 10)

**Возвращает:** Список словарей с данными чатов

**Логика:**
1. Использует `page.evaluate` для выполнения JavaScript на странице
2. Ищет элементы чатов через селекторы
3. Для каждого чата извлекает:
   - Имя (из `aria-label` или текстового содержимого)
   - Последнее сообщение
   - Время последнего сообщения
   - Количество непрочитанных
   - Аватар (если есть)
4. Генерирует ID чата в формате `chat_{index}__________`
5. Возвращает список распарсенных чатов

**JavaScript логика:**
- Ищет элементы через `querySelectorAll`
- Извлекает текст и атрибуты
- Фильтрует системные сообщения
- Обрабатывает ошибки парсинга отдельных чатов

---

### 15. `async def get_chats(self, session_id: str) -> List[Dict]`
**Назначение:** Получить список всех чатов (не streaming, блокирующий вызов)  
**Возвращает:** Список всех чатов

**Логика:**
1. Проверяет сессию
2. Ищет контейнер чатов
3. Парсит все чаты сразу
4. Возвращает полный список

**Отличие от `get_chats_streaming`:**
- Блокирующий вызов (не streaming)
- Возвращает все чаты сразу, а не батчами
- Используется для простых случаев, когда не нужна потоковая передача

---

### 16. `async def get_chat_messages_streaming(self, session_id: str, chat_id: str, limit: Optional[int] = None) -> AsyncGenerator[Dict, None]`
**Назначение:** Получить сообщения из чата с потоковой передачей  
**Параметры:**
- `session_id` - ID сессии
- `chat_id` - ID чата (формат: `chat_2__________`)
- `limit` - ограничение количества сообщений (опционально)

**Возвращает:** AsyncGenerator, который yield'ит:
- `{'type': 'progress', 'loaded': int, 'total': int}` - прогресс загрузки
- `{'type': 'message', 'message': Dict}` - данные сообщения
- `{'type': 'complete', 'total': int}` - завершение загрузки
- `{'type': 'error', 'error': str}` - ошибка

**Логика работы:**
1. Проверяет сессию и её готовность
2. Извлекает индекс чата из `chat_id` (например, `chat_2__________` -> индекс 2)
3. Ищет элемент чата по индексу в списке чатов
4. Кликает на чат
5. Ждет открытия панели чата (проверяет наличие элементов сообщений)
6. Ищет контейнер сообщений через JavaScript (broad-search стратегия)
7. Парсит начальные сообщения (видимые без скроллинга)
8. Скроллит вверх для загрузки старых сообщений
9. Парсит сообщения после каждого скролла
10. Yield'ит сообщения по мере парсинга
11. Продолжает скроллить до тех пор, пока не загрузит все или не достигнет лимита

**Поиск контейнера сообщений:**
- Использует JavaScript для поиска scrollable контейнеров
- Ищет div'ы с большим `scrollHeight`
- Сортирует по `scrollHeight` и выбирает самый большой
- Использует индекс для получения элемента через `query_selector_all`

**Скроллинг:**
- Скроллит вверх (`scrollTop = 0`) для загрузки старых сообщений
- Ждет после каждого скролла (2 секунды)
- Проверяет, появились ли новые сообщения
- Останавливается, если новых сообщений не появилось после нескольких попыток

**Особенности:**
- Очень сложная логика поиска контейнера (из-за динамической структуры WhatsApp Web)
- Использует broad-search как fallback стратегию
- Делает скриншоты при ошибках для отладки
- Логирует подробную диагностику DOM

---

### 17. `async def _parse_all_messages(self, page, container=None) -> List[Dict]`
**Назначение:** Парсинг всех видимых сообщений из контейнера или страницы  
**Параметры:**
- `page` - Playwright Page объект
- `container` - опциональный контейнер для парсинга (ElementHandle)

**Возвращает:** Список словарей с данными сообщений

**Логика:**
1. Если контейнер передан - проверяет его валидность (scrollHeight, clientHeight, childCount)
2. Если контейнер не передан - ищет его через стандартные селекторы
3. Использует `container.evaluate` для выполнения JavaScript внутри контейнера
4. Ищет элементы сообщений через селекторы:
   - `div[data-testid="msg-container"]`
   - `div[data-id]`
   - `div[role="row"]`
5. Если не находит - использует broad-search (ищет все div'ы с текстом/медиа)
6. Для каждого элемента сообщения извлекает:
   - Текст сообщения
   - Время отправки
   - Отправителя (если групповой чат)
   - Тип сообщения (текст, изображение, видео, аудио, файл)
   - Медиа (изображения, видео, аудио)
   - Статус доставки
   - ID сообщения
7. Фильтрует системные сообщения
8. Убирает дубликаты по ID
9. Возвращает список сообщений

**JavaScript логика парсинга:**
- Ищет элементы внутри контейнера (не по всей странице!)
- Извлекает текст из `span.selectable-text` или `[data-testid="msg-text"]`
- Извлекает время из атрибутов или текста
- Определяет тип сообщения по наличию медиа элементов
- Обрабатывает ошибки парсинга отдельных сообщений

**Критически важно:**
- Должен искать сообщения **внутри контейнера**, а не по всей странице
- Использует `element.querySelectorAll` вместо `document.querySelectorAll`
- Переменная `msgElement` используется для элементов сообщений (не `element`, чтобы избежать конфликта)

**Формат данных сообщения:**
```python
{
    "id": str,  # уникальный ID сообщения
    "text": str | None,  # текст сообщения
    "timestamp": str,  # время отправки
    "sender": str | None,  # отправитель (для групповых чатов)
    "type": str,  # "text", "image", "video", "audio", "file"
    "media": str | None,  # base64 медиа (для изображений/видео)
    "status": str | None  # статус доставки
}
```

---

### 18. `async def get_chat_messages(self, session_id: str, chat_id: str) -> List[Dict]`
**Назначение:** Получить все сообщения из чата (не streaming, блокирующий вызов)  
**Возвращает:** Список всех сообщений

**Логика:**
1. Проверяет сессию
2. Находит и открывает чат
3. Парсит все сообщения
4. Возвращает полный список

**Отличие от `get_chat_messages_streaming`:**
- Блокирующий вызов
- Возвращает все сообщения сразу
- Не использует streaming подход

---

## Глобальный экземпляр

В конце файла создается глобальный экземпляр сервиса:
```python
whatsapp_service = WhatsAppConnectService()
```

Этот экземпляр используется в API endpoints для работы с WhatsApp.

---

## Ключевые особенности реализации

### 1. Persistent Browser Context
- Использует `launch_persistent_context` для сохранения cookies и состояния браузера
- Данные сохраняются в `{sessions_dir}/{session_id}/browser_data/`
- Позволяет переиспользовать сессии без повторной авторизации

### 2. Headless Browser
- Браузер запускается в headless режиме (без GUI)
- Использует аргументы для обхода детекции автоматизации
- Переопределяет `navigator.webdriver` для скрытия автоматизации

### 3. Асинхронность
- Все операции асинхронные (async/await)
- Использует AsyncGenerator для streaming данных
- Не блокирует выполнение при долгих операциях

### 4. Обработка ошибок
- Подробное логирование всех операций
- Обработка исключений на каждом уровне
- Скриншоты при критических ошибках
- Диагностика DOM структуры при проблемах

### 5. Поиск элементов
- Множественные стратегии поиска (fallback)
- JavaScript-based поиск для сложных случаев
- Broad-search как последняя попытка
- Использование индексов для надежности

### 6. Streaming подход
- `get_chats_streaming` - для постепенной загрузки чатов
- `get_chat_messages_streaming` - для постепенной загрузки сообщений
- Позволяет показывать прогресс пользователю
- Не блокирует UI при больших объемах данных

---

## Проблемы и решения

### Проблема: Поиск контейнера сообщений
**Проблема:** WhatsApp Web имеет динамическую структуру DOM, контейнер сообщений сложно найти.

**Решение:**
- Множественные стратегии поиска (селекторы, JavaScript broad-search)
- Использование индексов элементов
- Подробная диагностика DOM при ошибках

### Проблема: Парсинг сообщений внутри контейнера
**Проблема:** Сообщения должны парситься внутри контейнера, а не по всей странице.

**Решение:**
- Использование `container.evaluate` вместо `page.evaluate`
- Поиск через `element.querySelectorAll` внутри контейнера
- Передача контейнера как параметра в `_parse_all_messages`

### Проблема: Переиспользование контейнера
**Проблема:** Контейнер находился, но терялся при проверке валидности.

**Решение:**
- Убрана установка `container = None` при ошибке проверки
- Контейнер используется в любом случае, если был передан
- Улучшено логирование для отладки

---

## Логирование

Все операции логируются с использованием:
- `trace_id` - для отслеживания запроса
- `request_id` - для идентификации конкретного запроса
- Уровни: INFO, WARNING, ERROR, DEBUG
- Подробная диагностика при ошибках

---

## Зависимости от настроек

- `settings.WHATSAPP_SESSIONS_DIR` - директория для хранения сессий
- Используется для создания путей к сессиям

---

## Итог

Файл `whatsapp_connect.py` - это сложный модуль для автоматизации WhatsApp Web через Playwright. Он управляет сессиями, подключениями, парсингом чатов и сообщений, используя современные подходы (streaming, persistent context, async/await). Код содержит множество fallback стратегий для надежной работы с динамическим DOM WhatsApp Web.
